{"version":3,"sources":["../../src/framework/fixture.ts"],"names":["Fixture","constructor","rec","params","init","log","msg","finalize","numOutstandingAsyncExpectations","Error","warn","fail","ok","m","asyncExpectation","fn","expectErrorValue","expectedName","ex","actualName","name","shouldReject","p","shouldThrow","expect","cond"],"mappings":";;;;;;AAGA;AACA;AACA;AACA,OAAO,MAAMA,OAAN,CAAc;AAKnBC,EAAAA,WAAW,CAACC,GAAD,EAAwBC,MAAxB,EAA2C;AAAA;;AAAA;;AAAA,6DAFZ,CAEY;;AACpD,SAAKD,GAAL,GAAWA,GAAX;AACA,SAAKC,MAAL,GAAcA,MAAd;AACD,GARkB,CAUnB;AACA;;;AACA,QAAMC,IAAN,GAA4B,CAAE;;AAE9BC,EAAAA,GAAG,CAACC,GAAD,EAAoB;AACrB,SAAKJ,GAAL,CAASG,GAAT,CAAaC,GAAb;AACD;;AAEDC,EAAAA,QAAQ,GAAS;AACf,QAAI,KAAKC,+BAAL,KAAyC,CAA7C,EAAgD;AAC9C,YAAM,IAAIC,KAAJ,CACJ,6FADI,CAAN;AAGD;AACF;;AAEDC,EAAAA,IAAI,CAACJ,GAAD,EAAqB;AACvB,SAAKJ,GAAL,CAASQ,IAAT,CAAcJ,GAAd;AACD;;AAEDK,EAAAA,IAAI,CAACL,GAAD,EAAqB;AACvB,SAAKJ,GAAL,CAASS,IAAT,CAAcL,GAAd;AACD;;AAEDM,EAAAA,EAAE,CAACN,GAAD,EAAqB;AACrB,UAAMO,CAAC,GAAGP,GAAG,GAAG,OAAOA,GAAV,GAAgB,EAA7B;AACA,SAAKD,GAAL,CAAS,OAAOQ,CAAhB;AACD;;AAED,QAAgBC,gBAAhB,CAAiCC,EAAjC,EAAyE;AACvE,SAAKP,+BAAL;AACA,UAAMO,EAAE,EAAR;AACA,SAAKP,+BAAL;AACD;;AAEOQ,EAAAA,gBAAR,CAAyBC,YAAzB,EAA+CC,EAA/C,EAA4DL,CAA5D,EAA6E;AAC3E,QAAI,EAAEK,EAAE,YAAYT,KAAhB,CAAJ,EAA4B;AAC1B,WAAKE,IAAL,CAAU,iBAAV;AACA;AACD;;AACD,UAAMQ,UAAU,GAAGD,EAAE,CAACE,IAAtB;;AACA,QAAID,UAAU,KAAKF,YAAnB,EAAiC;AAC/B,WAAKN,IAAL,CAAW,SAAQQ,UAAW,eAAcF,YAAa,GAAEJ,CAAE,EAA7D;AACD,KAFD,MAEO;AACL,WAAKD,EAAL,CAAS,SAAQO,UAAW,GAAEN,CAAE,EAAhC;AACD;AACF;;AAED,QAAMQ,YAAN,CAAmBJ,YAAnB,EAAyCK,CAAzC,EAA8DhB,GAA9D,EAA2F;AACzF,SAAKQ,gBAAL,CAAsB,YAAY;AAChC,YAAMD,CAAC,GAAGP,GAAG,GAAG,OAAOA,GAAV,GAAgB,EAA7B;;AACA,UAAI;AACF,cAAMgB,CAAN;AACA,aAAKX,IAAL,CAAU,kBAAkBE,CAA5B;AACD,OAHD,CAGE,OAAOK,EAAP,EAAW;AACX,aAAKF,gBAAL,CAAsBC,YAAtB,EAAoCC,EAApC,EAAwCL,CAAxC;AACD;AACF,KARD;AASD;;AAEDU,EAAAA,WAAW,CAACN,YAAD,EAAuBF,EAAvB,EAAuCT,GAAvC,EAA2D;AACpE,UAAMO,CAAC,GAAGP,GAAG,GAAG,OAAOA,GAAV,GAAgB,EAA7B;;AACA,QAAI;AACFS,MAAAA,EAAE;AACF,WAAKJ,IAAL,CAAU,kBAAkBE,CAA5B;AACD,KAHD,CAGE,OAAOK,EAAP,EAAW;AACX,WAAKF,gBAAL,CAAsBC,YAAtB,EAAoCC,EAApC,EAAwCL,CAAxC;AACD;AACF;;AAEDW,EAAAA,MAAM,CAACC,IAAD,EAAgBnB,GAAhB,EAAuC;AAC3C,QAAImB,IAAJ,EAAU;AACR,WAAKb,EAAL,CAAQN,GAAR;AACD,KAFD,MAEO;AACL,WAAKJ,GAAL,CAASS,IAAT,CAAcL,GAAd;AACD;;AACD,WAAOmB,IAAP;AACD;;AAvFkB","sourcesContent":["import { TestCaseRecorder } from './logger.js';\nimport { ParamsAny } from './params/index.js';\n\n// A Fixture is a class used to instantiate each test case at run time.\n// A new instance of the Fixture is created for every single test case\n// (i.e. every time the test function is run).\nexport class Fixture {\n  params: ParamsAny;\n  protected rec: TestCaseRecorder;\n  private numOutstandingAsyncExpectations = 0;\n\n  constructor(rec: TestCaseRecorder, params: ParamsAny) {\n    this.rec = rec;\n    this.params = params;\n  }\n\n  // This has to be a member function instead of an async `createFixture` function, because\n  // we need to be able to ergonomically override it in subclasses.\n  async init(): Promise<void> {}\n\n  log(msg: string): void {\n    this.rec.log(msg);\n  }\n\n  finalize(): void {\n    if (this.numOutstandingAsyncExpectations !== 0) {\n      throw new Error(\n        'there were outstanding asynchronous expectations (e.g. shouldReject) at the end of the test'\n      );\n    }\n  }\n\n  warn(msg?: string): void {\n    this.rec.warn(msg);\n  }\n\n  fail(msg?: string): void {\n    this.rec.fail(msg);\n  }\n\n  ok(msg?: string): void {\n    const m = msg ? ': ' + msg : '';\n    this.log('OK' + m);\n  }\n\n  protected async asyncExpectation(fn: () => Promise<void>): Promise<void> {\n    this.numOutstandingAsyncExpectations++;\n    await fn();\n    this.numOutstandingAsyncExpectations--;\n  }\n\n  private expectErrorValue(expectedName: string, ex: unknown, m: string): void {\n    if (!(ex instanceof Error)) {\n      this.fail('THREW NON-ERROR');\n      return;\n    }\n    const actualName = ex.name;\n    if (actualName !== expectedName) {\n      this.fail(`THREW ${actualName} INSTEAD OF ${expectedName}${m}`);\n    } else {\n      this.ok(`threw ${actualName}${m}`);\n    }\n  }\n\n  async shouldReject(expectedName: string, p: Promise<unknown>, msg?: string): Promise<void> {\n    this.asyncExpectation(async () => {\n      const m = msg ? ': ' + msg : '';\n      try {\n        await p;\n        this.fail('DID NOT THROW' + m);\n      } catch (ex) {\n        this.expectErrorValue(expectedName, ex, m);\n      }\n    });\n  }\n\n  shouldThrow(expectedName: string, fn: () => void, msg?: string): void {\n    const m = msg ? ': ' + msg : '';\n    try {\n      fn();\n      this.fail('DID NOT THROW' + m);\n    } catch (ex) {\n      this.expectErrorValue(expectedName, ex, m);\n    }\n  }\n\n  expect(cond: boolean, msg?: string): boolean {\n    if (cond) {\n      this.ok(msg);\n    } else {\n      this.rec.fail(msg);\n    }\n    return cond;\n  }\n}\n"],"file":"fixture.js"}